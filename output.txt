Folder Structure
--------------------------------------------------
./
    README.md
    cmd/
        adbt/
            main.go
    screenshots/
        dashboard.png
        device_info.png
    internal/
        ui/
            app.go
            screens/
                device_info.go
                logcat.go
                actions.go
                messages.go
                dashboard.go
                devices.go
            components/
                header.go
                list.go
                keyvalue.go
                layout.go
                styles.go
                toast.go
                form.go
                confirm.go
        state/
            app.go
        adb/
            device_info.go
            logcat.go
            client.go
            devices.go


File Contents
--------------------------------------------------


README.md
File type: .md
# adbt: A Terminal UI for Android Debug Bridge

**adbt** is a modern, interactive terminal application built on the Android Debug Bridge (ADB). It provides a structured, keyboard-driven interface for managing Android devices directly within the terminal environment.

Developed using Go and the Charm Bracelet's Bubble Tea framework, `adbt` emphasizes clarity, performance, and correctness, offering a powerful alternative to raw command-line ADB interactions.

---

## Screenshots

|                    Screen View                     |
| :------------------------------------------------: |
|                **Dashboard Screen**                |
|   ![Dashboard Screen](screenshots/dashboard.png)   |
|               **Device Info Screen**               |
| ![Device Info Screen](screenshots/device_info.png) |

## 1\. Key Features

### Device Management and Control

-   **Device Discovery:** Automatically lists all connected Android devices and displays detailed information including Model, Serial, Android version, and current state.
-   **Automatic Selection:** Automatically selects the device when only a single device is connected.
-   **Destructive Actions:** Provides one-click access to critical device functions with mandatory confirmation prompts:
    -   Reboot device (`adb reboot`).
    -   Reboot to Recovery (`adb reboot recovery`).
    -   Reboot to Bootloader (`adb reboot bootloader`).
-   **Screen Mirroring:** Quick action to launch the external **scrcpy** tool for the selected device.

### Interactive Tools

-   **Live Logcat Viewer:** Streams and displays device log output in real-time within the TUI. Features include the ability to **clear** logs and **start/stop** the incoming stream.
-   **Dashboard:** A centralized screen providing an overview of the selected device's status and quick access to all major features via single-key shortcuts.
-   **ADB Shell:** Designated screen for interactive shell access (currently defined as a feature, with TUI implementation pending).

### Architecture and User Experience

-   **Keyboard-First Design:** The application is entirely keyboard-navigable, using standard key bindings:
    -   **Navigation:** `â†‘ / â†“` or `j / k`
    -   **Selection/Confirmation:** `enter`
    -   **Back/Cancel:** `esc`
    -   **Quick Actions:** Single-key shortcuts (e.g., `d`, `l`, `i`).
-   **Modal Input Handling:** Confirmation prompts and dialogs fully capture input, preventing key presses from affecting the underlying screen state, ensuring reliable execution of critical commands.
-   **Modular UI:** Built upon reusable Bubble Tea components (layouts, toasts, confirmation modals) for a consistent and robust visual experience.

---

## 2\. Technologies Used

| Category               | Technology                                               | Purpose                                                                     |
| :--------------------- | :------------------------------------------------------- | :-------------------------------------------------------------------------- |
| **Language**           | Go (Golang)                                              | Primary application development language (Go 1.21+).                        |
| **TUI Framework**      | [Bubble Tea](https://github.com/charmbracelet/bubbletea) | Implementation of the Terminal UI using The Elm Architecture.               |
| **Styling**            | [Lip Gloss](https://github.com/charmbracelet/lipgloss)   | Used for advanced terminal styling, layout, and visual component rendering. |
| **Tooling**            | Android SDK Platform Tools (`adb`)                       | The essential dependency for all device communication.                      |
| **Tooling (Optional)** | `scrcpy`                                                 | External utility used to enable the screen mirroring feature.               |

---

## 3\. Prerequisites and Installation

### Requirements

To run and build `adbt`, the following are mandatory:

1.  **Go:** Version 1.21 or newer.
2.  **Android SDK Platform Tools:** The `adb` executable must be installed and accessible in your system's `$PATH`.
3.  **An Android Device:** A physical device or emulator must be connected with USB debugging enabled.

### Detailed Installation Steps (Build from Source)

The following steps guide you through cloning the repository, building the executable, and making it globally accessible.

1.  **Clone the Repository:**

    ```bash
    git clone https://github.com/<your-username>/adbt
    cd adbt
    ```

2.  **Build the Executable:**
    The `go build` command compiles the source code, targeting the entry point in `cmd/adbt/main.go`.

    ```bash
    go build -o adbt ./cmd/adbt
    ```

    This creates an executable file named `adbt` in the project root.

3.  **Run Locally:**
    To execute the application from the project directory:

    ```bash
    ./adbt
    ```

4.  **(Optional) Install to PATH:**
    To use `adbt` globally from any terminal directory, move the executable to a directory included in your `$PATH` (e.g., `/usr/local/bin`):

    ```bash
    sudo mv adbt /usr/local/bin
    ```

    You can now launch the application using only the command name:

    ```bash
    adbt
    ```

---

## 4\. Usage and Key Commands

### Launching

Ensure an ADB-enabled device is connected before launching.

```bash
adbt
```

### Core Navigation and Global Bindings

| Key Binding     | Screen    | Action                                                       |
| :-------------- | :-------- | :----------------------------------------------------------- |
| `q` or `Ctrl+c` | Global    | Quits the application.                                       |
| `esc`           | Global    | Returns to the Dashboard or cancels an active dialog/prompt. |
| `enter` / `y`   | Prompt    | Confirms an action within a dialog.                          |
| `esc` / `n`     | Prompt    | Cancels an action within a dialog.                           |
| `d`             | Dashboard | Switches to the **Device Selection** screen.                 |

### Dashboard (Menu) Actions

The Dashboard acts as the primary hub for device interaction.

| Key | Menu Item   | Device Requirement | Function                                                             |
| :-- | :---------- | :----------------- | :------------------------------------------------------------------- |
| `d` | Devices     | No                 | View and select connected devices.                                   |
| `i` | Device Info | Yes                | View detailed properties and control device states (reboot, scrcpy). |
| `l` | Logcat      | Yes                | Access the live log viewer.                                          |
| `s` | Shell       | Yes                | Access the interactive ADB shell.                                    |

### Logcat Viewer Actions

| Key | Function   | Description                                     |
| :-- | :--------- | :---------------------------------------------- |
| `c` | Clear      | Clears the log history currently displayed.     |
| `s` | Start/Stop | Pauses or resumes the real-time logging stream. |

### Device Control (Device Info Screen) Actions

Actions on the Device Info screen trigger immediate confirmation prompts.

| Key | Action               | ADB Command Executed (if confirmed) |
| :-- | :------------------- | :---------------------------------- |
| `s` | Start Scrcpy         | `scrcpy -s <serial>`                |
| `r` | Reboot               | `adb -s <serial> reboot`            |
| `R` | Reboot to Recovery   | `adb -s <serial> reboot recovery`   |
| `b` | Reboot to Bootloader | `adb -s <serial> reboot bootloader` |

---

## 5\. Project Structure

The codebase is organized to separate concerns between the UI framework, global state, and the underlying ADB logic, following the Bubble Tea pattern.

```text
adbt/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ adbt/
â”‚       â””â”€â”€ main.go       # Application entry point; initializes the Bubble Tea program.
â””â”€â”€ internal/
    â”œâ”€â”€ adb/              # Contains all functions that execute 'adb' commands.
    â”‚   â”œâ”€â”€ client.go     # Low-level command execution and error handling (ExecuteCommand).
    â”‚   â”œâ”€â”€ devices.go    # Logic for listing devices and fetching properties.
    â”‚   â”œâ”€â”€ logcat.go     # Manages the streaming logcat process using channels and messages.
    â”‚   â””â”€â”€ device_info.go# Wrappers for device control commands (reboot, scrcpy).
    â”œâ”€â”€ state/            # Defines the global, mutable application data.
    â”‚   â””â”€â”€ app.go        # AppState: holds the selected device, device list, and screen dimensions.
    â””â”€â”€ ui/               # All TUI components and screen logic.
        â”œâ”€â”€ app.go        # The root TUI model and router; manages screen switching.
        â”œâ”€â”€ components/   # Reusable UI primitives (views, styles, modals).
        â”‚   â”œâ”€â”€ styles.go # Defines all terminal styling using Lip Gloss.
        â”‚   â””â”€â”€ confirm.go# Logic for the mandatory confirmation prompt modal.
        â””â”€â”€ screens/      # Dedicated Bubble Tea models for each primary view.
            â”œâ”€â”€ dashboard.go# The main menu and status overview.
            â”œâ”€â”€ devices.go  # The device selection list.
            â”œâ”€â”€ logcat.go   # The logcat stream viewer.
            â””â”€â”€ actions.go  # Helper functions to resolve actions into screen switching commands.
```

---

## 6\. Contributing

We welcome contributions, issue reports, and discussions. If you are interested in terminal UIs, Go development, Bubble Tea, or Android tooling, you are encouraged to get involved.

Please follow standard GitHub practices: fork the repository, create a feature branch, and submit a pull request for review.

---

## 7\. License

This project is released under the **MIT License**.



--------------------------------------------------
File End
--------------------------------------------------


cmd/adbt/main.go
File type: .go
package main

import (
	"log"
	"os"

	"adbt/internal/ui"

	tea "github.com/charmbracelet/bubbletea"
)

func main() {
	p := tea.NewProgram(
		ui.NewApp(),
		tea.WithAltScreen(),
		tea.WithMouseCellMotion(),
	)

	if _, err := p.Run(); err != nil {
		log.Printf("Error: %v", err)
		os.Exit(1)
	}
}


--------------------------------------------------
File End
--------------------------------------------------


screenshots/dashboard.png
File type: .png
[Binary/Non-UTF8 file - showing first 500 chars]
Â‰PNG

   
IHDR  Â¤  c   2Ã‰Ã¦  }iCCPICC Profile  XÂ…Â•y	8Â•]Ã—Ã¿Â¾Ã|ÂÃ¹Ã³<ÃdÂÃ§yÂgÂÃ©Â˜Ã¢CÂ‰Â¤%Â¢TÂ’Â±R)T"Ã’Â Â”Â¡Â‡$Â‰dÂ¨**CÂ¾Ã›PÃÃ³>Ã¯Ã¿ÃºÃ—Â·ÃÂµÃ¯Ã½;kÂ¯Â½Ã–ÃkÃ­iÃ7 \#Â¾Â‘Â‘aF Ã‚#bÂ¨Â¦Ã¼nÃ®Ã¼Ã˜Â€ÂÂ¬Â€ Â¾Ã¤Ã¨H};;+ Â§ÃŸÃ¥Â¦Â¥A mÂ”Ãe6dÃ½wÃ½Ã¿7Ã½Â¢Ã‰ @^0Ã¶Ã³Â&Â‡ÃƒÃ¸. Â¨SÃ¤Hj Â˜
ÂºP|LÃ¤Ãcf*ÃœAlÃ Â -\Â½ÂÃ½Â¶pÃ‹&ÂÂ“Âƒ!ÂŒ{Ã€Ã‘ÃºÃºRÂƒ Â ÂÃ©Ã¼qÃ¤ XÃ½*\GÂŒÃ°Â§D Ã€ÂÂ£CÃ¶ÃµÂ€Ã‹Ã¦Â‘ÃŸÂ½ÂÂ“a,Ã³GÃ‚Â¸Ã†j~Ã¿ÂÃ´Ã²Ã½Ã¾ÃˆÃ·Ãµ
ÃºÂƒÂ·Ã†ÂµÂ™pFÂ”Ã¨Ãˆ0ÃŸ=Ã¿GÃ“Ã¼Ã¯)<,Ã¶Â·Q8Ã“SÃ6Ã†Ã›p(tÂ·Ã¥Â¦Â…Ã±lÂ„ÂŸÂÃ­Â†Â­aÃ¼ÂƒÃ¢Â¿ew Â„Ã X3Ã§-~79ÃšÂ¶Ã¬sÂ€ÂÃ³Ã·5Â²Â„17ÂŒM"Ã‚lÂ¬Â¶Ã©~ÂsÃƒ6C$PbÃŒÂ`ÃŒÃ£ÃƒÃ‘Ã†ÂÃ›<gÂ©Â»Â¶u!Â©Â†ÃºÃ›Ã´GÂ¾Ã”MÂ½ÂºFcCÂÃµÂ·Ã¥	0ÃŸÂ–ÂÂ¤OvrÂ…1Ã†Ã‚qÃ“ÃƒX...

--------------------------------------------------
File End
--------------------------------------------------


screenshots/device_info.png
File type: .png
[Binary/Non-UTF8 file - showing first 500 chars]
Â‰PNG

   
IHDR  Â¤  c   2Ã‰Ã¦  }iCCPICC Profile  XÂ…Â•y	8Â•]Ã—Ã¿Â¾Ã|ÂÃ¹Ã³<ÃdÂÃ§yÂgÂÃ©Â˜Ã¢CÂ‰Â¤%Â¢TÂ’Â±R)T"Ã’Â Â”Â¡Â‡$Â‰dÂ¨**CÂ¾Ã›PÃÃ³>Ã¯Ã¿ÃºÃ—Â·ÃÂµÃ¯Ã½;kÂ¯Â½Ã–ÃkÃ­iÃ7 \#Â¾Â‘Â‘aF Ã‚#bÂ¨Â¦Ã¼nÃ®Ã¼Ã˜Â€ÂÂ¬Â€ Â¾Ã¤Ã¨H};;+ Â§ÃŸÃ¥Â¦Â¥A mÂ”Ãe6dÃ½wÃ½Ã¿7Ã½Â¢Ã‰ @^0Ã¶Ã³Â&Â‡ÃƒÃ¸. Â¨SÃ¤Hj Â˜
ÂºP|LÃ¤Ãcf*ÃœAlÃ Â -\Â½ÂÃ½Â¶pÃ‹&ÂÂ“Âƒ!ÂŒ{Ã€Ã‘ÃºÃºRÂƒ Â ÂÃ©Ã¼qÃ¤ XÃ½*\GÂŒÃ°Â§D Ã€ÂÂ£CÃ¶ÃµÂ€Ã‹Ã¦Â‘ÃŸÂ½ÂÂ“a,Ã³GÃ‚Â¸Ã†j~Ã¿ÂÃ´Ã²Ã½Ã¾ÃˆÃ·Ãµ
ÃºÂƒÂ·Ã†ÂµÂ™pFÂ”Ã¨Ãˆ0ÃŸ=Ã¿GÃ“Ã¼Ã¯)<,Ã¶Â·Q8Ã“SÃ6Ã†Ã›p(tÂ·Ã¥Â¦Â…Ã±lÂ„ÂŸÂÃ­Â†Â­aÃ¼ÂƒÃ¢Â¿ew Â„Ã X3Ã§-~79ÃšÂ¶Ã¬sÂ€ÂÃ³Ã·5Â²Â„17ÂŒM"Ã‚lÂ¬Â¶Ã©~ÂsÃƒ6C$PbÃŒÂ`ÃŒÃ£ÃƒÃ‘Ã†ÂÃ›<gÂ©Â»Â¶u!Â©Â†ÃºÃ›Ã´GÂ¾Ã”MÂ½ÂºFcCÂÃµÂ·Ã¥	0ÃŸÂ–ÂÂ¤OvrÂ…1Ã†Ã‚qÃ“ÃƒX...

--------------------------------------------------
File End
--------------------------------------------------


internal/ui/app.go
File type: .go
package ui

import (
	"adbt/internal/state"
	"adbt/internal/ui/screens"

	tea "github.com/charmbracelet/bubbletea"
)

type App struct {
	state         *state.AppState
	currentScreen tea.Model
	screenName    string
}

func NewApp() *App {
	appState := state.New()

	return &App{
		state:         appState,
		currentScreen: screens.NewDashboard(appState),
		screenName:    "dashboard",
	}
}

func (a *App) Init() tea.Cmd {
	return a.currentScreen.Init()
}

func (a *App) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		a.state.Width = msg.Width
		a.state.Height = msg.Height

	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return a, tea.Quit

		case "esc":

			if a.screenName != "dashboard" {
				return a.switchScreen("dashboard")
			}
		}

	case screens.SwitchScreenMsg:
		return a.switchScreen(msg.Screen)
	}

	var cmd tea.Cmd
	a.currentScreen, cmd = a.currentScreen.Update(msg)
	return a, cmd
}

func (a *App) switchScreen(name string) (*App, tea.Cmd) {
	var newScreen tea.Model

	switch name {
	case "dashboard":
		newScreen = screens.NewDashboard(a.state)
	case "devices":
		newScreen = screens.NewDevices(a.state)
	case "logcat":
		newScreen = screens.NewLogcat(a.state)
	case "device_info":
		newScreen = screens.NewDeviceInfo(a.state)

	default:
		return a, nil
	}

	a.currentScreen = newScreen
	a.screenName = name
	return a, newScreen.Init()
}

func (a *App) View() string {
	if a.state.Width == 0 {
		return "Initializing..."
	}
	return a.currentScreen.View()
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/device_info.go
File type: .go
package screens

import (
	"strings"
	"time"

	"adbt/internal/adb"
	"adbt/internal/state"
	"adbt/internal/ui/components"

	tea "github.com/charmbracelet/bubbletea"
)

type deviceAction struct {
	key     string
	label   string
	run     func(string) error
	confirm bool
	prompt  string
}

type DeviceInfo struct {
	state *state.AppState

	actions       []deviceAction
	pendingAction deviceAction

	toast   components.Toast
	confirm components.ConfirmPrompt
}

func NewDeviceInfo(state *state.AppState) *DeviceInfo {
	return &DeviceInfo{
		state: state,
		actions: []deviceAction{
			{"s", "Start scrcpy (screen mirror)", adb.StartScrcpy, true, "Start screen mirroring?"},
			{"r", "Reboot device", adb.Reboot, true, "Reboot the device?"},
			{"R", "Reboot to recovery", adb.RebootRecovery, true, "Reboot into recovery?"},
			{"b", "Reboot to bootloader", adb.RebootBootloader, true, "Reboot into bootloader?"},
		},
	}
}

func (d *DeviceInfo) Init() tea.Cmd {
	return nil
}

func (d *DeviceInfo) Update(msg tea.Msg) (tea.Model, tea.Cmd) {

	d.toast.Update(msg)

	if d.confirm.Visible {
		if cmd := d.confirm.Update(msg); cmd != nil {
			return d, cmd
		}
	}

	switch msg := msg.(type) {
	case components.ConfirmYesMsg:
		d.confirm.Hide()
		return d, d.runAction(d.pendingAction)

	case components.ConfirmNoMsg:
		d.confirm.Hide()
		return d, nil

	case tea.KeyMsg:
		for _, a := range d.actions {
			if msg.String() != a.key {
				continue
			}

			if a.confirm {
				d.pendingAction = a
				d.confirm.Show(a.prompt)
				return d, nil
			}

			return d, d.runAction(a)
		}
	}

	return d, nil
}

func (d *DeviceInfo) runAction(a deviceAction) tea.Cmd {
	err := a.run(d.state.DeviceSerial())
	if err != nil {
		var cmd tea.Cmd
		d.toast, cmd = components.ShowToast(
			"Error: "+err.Error(),
			true,
			3*time.Second,
		)
		return cmd
	}

	var cmd tea.Cmd
	d.toast, cmd = components.ShowToast(
		"Command executed successfully",
		false,
		20*time.Second,
	)
	return cmd
}

func (d *DeviceInfo) View() string {
	if !d.state.HasDevice() {
		return components.RenderLayout(d.state, components.LayoutProps{
			Title:  "Device Info",
			Body:   components.StatusDisconnected.Render("No device selected"),
			Footer: components.Help("esc", "back"),
		})
	}

	dev := d.state.SelectedDevice
	var body strings.Builder

	body.WriteString(components.TitleStyle.Render("Device Details") + "\n")
	body.WriteString(
		components.KeyValueList([]components.KeyValueRow{
			{Key: "Model:", Value: dev.Model},
			{Key: "Serial:", Value: dev.Serial},
			{Key: "Android:", Value: dev.Android},
			{Key: "State:", Value: dev.State},
		}),
	)

	body.WriteString("\n")

	if d.confirm.Visible {
		body.WriteString(d.confirm.View())
	} else {
		body.WriteString(components.TitleStyle.Render("Actions") + "\n\n")
		for _, a := range d.actions {
			body.WriteString(
				components.HelpKeyStyle.Render("["+a.key+"]") +
					" " +
					components.ListItemStyle.Render(a.label) +
					"\n",
			)
		}
	}

	if d.toast.Visible {
		body.WriteString("\n\n")
		body.WriteString(d.toast.View())
	}

	return components.RenderLayout(d.state, components.LayoutProps{
		Title:  "Device Info",
		Body:   body.String(),
		Footer: components.Help("esc", "back") + "  " + components.Help("q", "quit"),
	})
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/logcat.go
File type: .go
package screens

import (
	"strings"

	"adbt/internal/adb"
	"adbt/internal/state"
	"adbt/internal/ui/components"

	tea "github.com/charmbracelet/bubbletea"
)

type Logcat struct {
	state   *state.AppState
	lines   []string
	session *adb.LogcatSession
	running bool
}

func NewLogcat(state *state.AppState) *Logcat {
	return &Logcat{state: state}
}

func (l *Logcat) Init() tea.Cmd {
	if !l.state.HasDevice() {
		return nil
	}
	l.running = true
	return adb.StartLogcatCmd(l.state.DeviceSerial())
}

func (l *Logcat) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {

	case adb.LogcatStartedMsg:
		l.session = msg.Session
		return l, adb.NextLogcatLineCmd(l.session)

	case adb.LogcatLineMsg:
		l.lines = append(l.lines, msg.Line)
		if len(l.lines) > 1000 {
			l.lines = l.lines[len(l.lines)-1000:]
		}
		if l.running {
			return l, adb.NextLogcatLineCmd(l.session)
		}

	case adb.LogcatStoppedMsg:
		l.running = false

	case tea.KeyMsg:
		switch msg.String() {
		case "c":
			l.lines = nil
		case "s":
			l.running = !l.running
			if l.running {
				return l, adb.NextLogcatLineCmd(l.session)
			}
		}
	}

	return l, nil
}

func (l *Logcat) View() string {
	if !l.state.HasDevice() {
		return components.RenderLayout(l.state, components.LayoutProps{
			Title: "Logcat",
			Body:  components.StatusDisconnected.Render("No device selected"),
		})
	}

	var body strings.Builder
	for _, line := range l.lines {
		body.WriteString(line + "\n")
	}

	return components.RenderLayout(l.state, components.LayoutProps{
		Title: "Logcat",
		Body:  body.String(),
		Footer: components.Help("c", "clear") + "  " +
			components.Help("s", "start/stop"),
	})
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/actions.go
File type: .go
package screens

import (
	"adbt/internal/state"

	tea "github.com/charmbracelet/bubbletea"
)

type Action string

const (
	ActionDevices    Action = "devices"
	ActionLogcat     Action = "logcat"
	ActionShell      Action = "shell"
	ActionApps       Action = "apps"
	ActionFiles      Action = "files"
	ActionDeviceInfo Action = "device_info"
)

func ResolveAction(action Action, state *state.AppState) tea.Cmd {
	switch action {

	case ActionDevices:
		return func() tea.Msg {
			return SwitchScreenMsg{Screen: "devices"}
		}

	case ActionLogcat:
		if !state.HasDevice() {
			return func() tea.Msg {
				return SwitchScreenMsg{Screen: "devices"}
			}
		}
		return func() tea.Msg {
			return SwitchScreenMsg{Screen: "logcat"}
		}

	case ActionShell, ActionApps, ActionFiles:
		if !state.HasDevice() {
			return func() tea.Msg {
				return SwitchScreenMsg{Screen: "devices"}
			}
		}
		return func() tea.Msg {
			return SwitchScreenMsg{Screen: string(action)}
		}

	case ActionDeviceInfo:
		if !state.HasDevice() {
			return func() tea.Msg {
				return SwitchScreenMsg{Screen: "devices"}
			}
		}
		return func() tea.Msg {
			return SwitchScreenMsg{Screen: "device_info"}
		}
	}

	return nil
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/messages.go
File type: .go
package screens

type SwitchScreenMsg struct {
	Screen string
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/dashboard.go
File type: .go
package screens

import (
	"strings"

	"adbt/internal/adb"
	"adbt/internal/state"
	"adbt/internal/ui/components"

	tea "github.com/charmbracelet/bubbletea"
)

type menuItem struct {
	key           string
	label         string
	description   string
	action        Action
	requireDevice bool
}

type Dashboard struct {
	state     *state.AppState
	loading   bool
	menuItems []menuItem
	cursor    int
}

func NewDashboard(appState *state.AppState) *Dashboard {
	return &Dashboard{
		state: appState,
		menuItems: []menuItem{
			{"d", "Devices", "View and select connected devices", ActionDevices, false},
			{"i", "Device Info", "View device details and controls", ActionDeviceInfo, true},
			{"l", "Logcat", "View live device logs", ActionLogcat, true},
			{"s", "Shell", "Interactive ADB shell", ActionShell, true},
			{"a", "Apps", "Manage installed applications", ActionApps, true},
			{"f", "Files", "Browse device storage", ActionFiles, true},
		},
	}
}

func (d *Dashboard) Init() tea.Cmd {
	d.loading = true
	return adb.ListDevices()
}

func (d *Dashboard) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {

	case adb.DevicesLoadedMsg:
		d.loading = false
		if msg.Error == nil {
			d.state.Devices = msg.Devices
			if len(msg.Devices) == 1 && msg.Devices[0].IsConnected() {
				d.state.SelectDevice(&msg.Devices[0])
			}
		}

	case tea.KeyMsg:
		switch msg.String() {
		case "up", "k":
			if d.cursor > 0 {
				d.cursor--
			}
		case "down", "j":
			if d.cursor < len(d.menuItems)-1 {
				d.cursor++
			}
		case "enter":
			item := d.menuItems[d.cursor]
			return d, ResolveAction(item.action, d.state)
		default:
			for _, item := range d.menuItems {
				if msg.String() == item.key {
					return d, ResolveAction(item.action, d.state)
				}
			}
		}
	}
	return d, nil
}

func (d *Dashboard) View() string {
	if d.loading {
		return components.RenderLayout(d.state, components.LayoutProps{
			Title: "Dashboard",
			Body:  "Loading devices...",
		})
	}

	var body strings.Builder

	body.WriteString(components.TitleStyle.Render("Device") + "\n")

	if d.state.HasDevice() {
		dev := d.state.SelectedDevice
		body.WriteString(
			components.KeyValueList([]components.KeyValueRow{
				{Key: "Status:", Value: components.StatusConnected.Render("â— Connected")},
				{Key: "Model:", Value: dev.Model},
				{Key: "Serial:", Value: dev.Serial},
				{Key: "Android:", Value: dev.Android},
				{Key: "State:", Value: dev.State},
			}),
		)
	} else {
		body.WriteString(components.StatusDisconnected.Render("â— No device connected\n"))
		body.WriteString(components.StatusMuted.Render(
			"Connect a device with USB debugging enabled.\nPress D to open device manager.",
		))
	}

	body.WriteString("\n")
	body.WriteString(components.TitleStyle.Render("Quick Actions") + "\n")

	for i, item := range d.menuItems {
		line := "  "
		if i == d.cursor {
			line = "â€º "
		}

		disabled := item.requireDevice && !d.state.HasDevice()

		if i == d.cursor {
			line += components.HelpKeyStyle.Render("[" + item.key + "]")
			line += " " + components.ListItemSelectedStyle.Render(item.label)
		} else {
			line += components.StatusMuted.Render("[" + item.key + "] ")
			line += components.ListItemStyle.Render(item.label)
		}

		line += " " + components.StatusMuted.Render("- "+item.description)

		if disabled {
			line += " " + components.ErrorStyle.Render("(requires device)")
		}

		body.WriteString(line + "\n")
	}

	return components.RenderLayout(d.state, components.LayoutProps{
		Title:  "Dashboard",
		Body:   body.String(),
		Footer: components.Help("â†‘/â†“", "navigate") + "  " + components.Help("enter", "select"),
	})
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/screens/devices.go
File type: .go
package screens

import (
	"strings"
	"time"

	"adbt/internal/adb"
	"adbt/internal/state"
	"adbt/internal/ui/components"

	tea "github.com/charmbracelet/bubbletea"
)

type Devices struct {
	state   *state.AppState
	cursor  int
	loading bool

	form  components.FormModal
	toast components.Toast
}

func NewDevices(appState *state.AppState) *Devices {
	return &Devices{
		state: appState,
	}
}

func (d *Devices) Init() tea.Cmd {
	d.loading = true
	return adb.ListDevices()
}

func (d *Devices) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	// toast lifecycle
	d.toast.Update(msg)

	// form modal has input precedence
	if d.form.Visible {
		if cmd := d.form.Update(msg); cmd != nil {
			return d, cmd
		}
		return d, nil
	}

	switch msg := msg.(type) {

	case tea.KeyMsg:
		switch msg.String() {

		case "up", "k":
			if d.cursor > 0 {
				d.cursor--
			}

		case "down", "j":
			if d.cursor < len(d.state.Devices)-1 {
				d.cursor++
			}

		case "enter":
			if len(d.state.Devices) > 0 && d.cursor < len(d.state.Devices) {
				device := &d.state.Devices[d.cursor]
				if device.IsConnected() {
					d.state.SelectDevice(device)
					return d, func() tea.Msg {
						return SwitchScreenMsg{Screen: "dashboard"}
					}
				}
			}

		case "w":
			d.form.Show(
				"Pair Device Wirelessly",
				[]components.FormField{
					{Label: "IP Address"},
					{Label: "Port"},
					{Label: "PIN Code"},
				},
				func(values []string) tea.Cmd {
					ip := values[0]
					port := values[1]
					pin := values[2]

					err := adb.PairWireless(ip, port, pin)
					if err != nil {
						var cmd tea.Cmd
						d.toast, cmd = components.ShowToast(
							"Pairing failed: "+err.Error(),
							true,
							3*time.Second,
						)
						return cmd
					}

					return adb.ListDevices()
				},
			)

		case "r":
			d.loading = true
			return d, adb.ListDevices()
		}

	case adb.DevicesLoadedMsg:
		d.loading = false
		if msg.Error == nil {
			d.state.Devices = msg.Devices

			if d.cursor >= len(d.state.Devices) {
				d.cursor = len(d.state.Devices) - 1
			}
			if d.cursor < 0 {
				d.cursor = 0
			}
		}
	}

	return d, nil
}

func (d *Devices) View() string {
	var body strings.Builder

	if d.loading {
		body.WriteString("Loading devices...")
	} else {
		body.WriteString(components.DeviceList(d.state.Devices, d.cursor))
	}

	if d.form.Visible {
		body.WriteString("\n\n")
		body.WriteString(d.form.View())
	}

	if d.toast.Visible {
		body.WriteString("\n\n")
		body.WriteString(d.toast.View())
	}

	return components.RenderLayout(d.state, components.LayoutProps{
		Title: "Device Selection",
		Body:  body.String(),
		Footer: components.Help("â†‘/â†“", "navigate") + "  " +
			components.Help("enter", "select") + "  " +
			components.Help("w", "wireless pair") + "  " +
			components.Help("r", "refresh") + "  " +
			components.Help("esc", "back"),
	})
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/header.go
File type: .go
package components

import (
	"fmt"

	"adbt/internal/state"
)

func RenderHeader(appState *state.AppState, screenName string) string {
	title := fmt.Sprintf("ADBT  |  %s", screenName)

	if appState.HasDevice() {
		device := appState.SelectedDevice
		title += StatusConnected.Render("  â— ")
		title += StatusMuted.Render(device.DisplayName())
	} else {
		title += StatusDisconnected.Render("  â— ")
		title += StatusMuted.Render("No device")
	}

	width := appState.Width - 4
	if width < 20 {
		width = 20
	}

	return HeaderStyle.Width(width).Render(title)
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/list.go
File type: .go
package components

import (
	"fmt"
	"strings"

	"adbt/internal/adb"
)

func DeviceList(devices []adb.Device, cursor int) string {
	if len(devices) == 0 {
		return ErrorStyle.Render("No devices found. Please connect a device with USB debugging enabled.")
	}

	var b strings.Builder
	b.WriteString(TitleStyle.Render("Connected Devices") + "\n\n")

	for i, device := range devices {
		cursorChar := " "
		style := ListItemStyle

		if i == cursor {
			cursorChar = "â€º"
			style = ListItemSelectedStyle
		}

		status := StatusDisconnected.Render("â—")
		if device.IsConnected() {
			status = StatusConnected.Render("â—")
		}

		line := fmt.Sprintf("%s %s %s", cursorChar, status, device.DisplayName())

		if device.IsConnected() && device.Android != "" {
			line += StatusMuted.Render(fmt.Sprintf(" - Android %s", device.Android))
		} else {
			line += StatusMuted.Render(fmt.Sprintf(" - %s", device.State))
		}

		b.WriteString(style.Render(line) + "\n")
	}

	return b.String()
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/keyvalue.go
File type: .go
package components

import "github.com/charmbracelet/lipgloss"

type KeyValueRow struct {
	Key   string
	Value string
}

func KeyValueList(rows []KeyValueRow) string {
	label := StatusMuted.
		Width(9).
		Align(lipgloss.Right)

	value := StatusMuted.
		Width(15).
		Align(lipgloss.Left)

	out := ""
	for _, r := range rows {
		out += label.Render(r.Key) + " " + value.Render(r.Value) + "\n"
	}
	return out
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/layout.go
File type: .go
package components

import (
	"strings"

	"adbt/internal/state"
)

type LayoutProps struct {
	Title  string
	Body   string
	Footer string
}

func RenderLayout(state *state.AppState, props LayoutProps) string {
	var b strings.Builder

	b.WriteString(RenderHeader(state, props.Title) + "\n")

	contentWidth := max(state.Width-4, 20)

	b.WriteString(
		ContentStyle.
			Width(contentWidth).
			Render(props.Body) + "\n",
	)

	if props.Footer != "" {
		b.WriteString(FooterStyle.Render(props.Footer))
	}

	return b.String()
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/styles.go
File type: .go
package components

import "github.com/charmbracelet/lipgloss"

var (
	Primary   = lipgloss.Color("#00D7FF")
	Secondary = lipgloss.Color("#7C3AED")
	Success   = lipgloss.Color("#10B981")
	Error     = lipgloss.Color("#EF4444")
	Muted     = lipgloss.Color("#6B7280")
	Border    = lipgloss.Color("#374151")

	HeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Primary).
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(Border).
			Padding(0, 2).
			Align(lipgloss.Center)

	ContentStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(Border).
			Padding(1, 2)

	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Primary)

	ListItemStyle = lipgloss.NewStyle().
			PaddingLeft(2)

	ListItemSelectedStyle = lipgloss.NewStyle().
				Foreground(Primary).
				Bold(true).
				PaddingLeft(1)

	StatusConnected = lipgloss.NewStyle().
			Foreground(Success).
			Bold(true)

	StatusDisconnected = lipgloss.NewStyle().
				Foreground(Error).
				Bold(true)

	StatusMuted = lipgloss.NewStyle().
			Foreground(Muted)

	FooterStyle = lipgloss.NewStyle().
			Foreground(Muted).
			Padding(0, 2)

	HelpKeyStyle = lipgloss.NewStyle().
			Foreground(Primary).
			Bold(true)

	HelpDescStyle = lipgloss.NewStyle().
			Foreground(Muted)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(Error).
			Bold(true)
)

func Help(key, desc string) string {
	return HelpKeyStyle.Render(key) + " " + HelpDescStyle.Render(desc)
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/toast.go
File type: .go
package components

import (
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

type Toast struct {
	Message string
	IsError bool
	Visible bool
}

type clearToastMsg struct{}

func ShowToast(msg string, isError bool, d time.Duration) (Toast, tea.Cmd) {
	return Toast{
			Message: msg,
			IsError: isError,
			Visible: true,
		},
		tea.Tick(d, func(time.Time) tea.Msg {
			return clearToastMsg{}
		})
}

func (t *Toast) Update(msg tea.Msg) {
	if _, ok := msg.(clearToastMsg); ok {
		t.Visible = false
		t.Message = ""
		t.IsError = false
	}
}

func (t *Toast) View() string {
	if !t.Visible {
		return ""
	}

	if t.IsError {
		return ErrorStyle.Render(t.Message)
	}

	return StatusConnected.Render(t.Message)
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/form.go
File type: .go
package components

import (
	"strings"
	"unicode"

	tea "github.com/charmbracelet/bubbletea"
)

type FormField struct {
	Label string
	Value string
}

type FormModal struct {
	Visible  bool
	Title    string
	Fields   []FormField
	Cursor   int
	OnSubmit func([]string) tea.Cmd
}

/* ---------- lifecycle ---------- */

func (f *FormModal) Show(
	title string,
	fields []FormField,
	onSubmit func([]string) tea.Cmd,
) {
	f.Visible = true
	f.Title = title
	f.Fields = fields
	f.Cursor = 0
	f.OnSubmit = onSubmit
}

func (f *FormModal) Hide() {
	f.Visible = false
	f.Title = ""
	f.Fields = nil
	f.Cursor = 0
	f.OnSubmit = nil
}

/* ---------- update ---------- */

func (f *FormModal) Update(msg tea.Msg) tea.Cmd {
	// ğŸ”’ hard safety guard
	if !f.Visible || len(f.Fields) == 0 {
		return nil
	}

	// ğŸ”’ clamp cursor
	if f.Cursor < 0 {
		f.Cursor = 0
	}
	if f.Cursor >= len(f.Fields) {
		f.Cursor = len(f.Fields) - 1
	}

	key, ok := msg.(tea.KeyMsg)
	if !ok {
		return nil
	}

	switch key.String() {

	case "tab", "down", "j":
		if f.Cursor < len(f.Fields)-1 {
			f.Cursor++
		}

	case "shift+tab", "up", "k":
		if f.Cursor > 0 {
			f.Cursor--
		}

	case "enter":
		if f.OnSubmit != nil {
			values := make([]string, len(f.Fields))
			for i := range f.Fields {
				values[i] = f.Fields[i].Value
			}
			f.Hide()
			return f.OnSubmit(values)
		}

	case "esc":
		f.Hide()
		return nil

	case "backspace":
		field := &f.Fields[f.Cursor]
		if len(field.Value) > 0 {
			field.Value = field.Value[:len(field.Value)-1]
		}

	default:
		if len(key.Runes) == 1 && unicode.IsPrint(key.Runes[0]) {
			f.Fields[f.Cursor].Value += string(key.Runes)
		}
	}

	return nil
}

/* ---------- view ---------- */

func (f *FormModal) View() string {
	if !f.Visible {
		return ""
	}

	var b strings.Builder

	b.WriteString(TitleStyle.Render(f.Title) + "\n\n")

	for i, field := range f.Fields {
		cursor := "  "
		if i == f.Cursor {
			cursor = "â€º "
		}

		label := StatusMuted.Render(field.Label + ":")
		value := field.Value
		if value == "" {
			value = StatusMuted.Render("<enter value>")
		}

		line := cursor + label + " " + value
		b.WriteString(line + "\n")
	}

	b.WriteString("\n")
	b.WriteString(
		HelpKeyStyle.Render("enter") + " submit    " +
			HelpKeyStyle.Render("esc") + " cancel    " +
			HelpKeyStyle.Render("tab") + " next",
	)

	return ContentStyle.Render(b.String())
}


--------------------------------------------------
File End
--------------------------------------------------


internal/ui/components/confirm.go
File type: .go
package components

import tea "github.com/charmbracelet/bubbletea"

type ConfirmYesMsg struct{}
type ConfirmNoMsg struct{}

type ConfirmPrompt struct {
	Visible bool
	Message string
}

func (c *ConfirmPrompt) Show(message string) {
	c.Visible = true
	c.Message = message
}

func (c *ConfirmPrompt) Hide() {
	c.Visible = false
	c.Message = ""
}

func (c *ConfirmPrompt) Update(msg tea.Msg) tea.Cmd {
	if !c.Visible {
		return nil
	}

	if key, ok := msg.(tea.KeyMsg); ok {
		switch key.String() {
		case "y", "enter":
			return func() tea.Msg { return ConfirmYesMsg{} }
		case "n", "esc":
			return func() tea.Msg { return ConfirmNoMsg{} }
		}
	}

	return nil
}

func (c *ConfirmPrompt) View() string {
	if !c.Visible {
		return ""
	}

	out := ""
	out += ErrorStyle.Render(
		"Are you sure?\n" +
			c.Message +
			"\n\n",
	)
	out += HelpKeyStyle.Render("[y]") + " Yes    "
	out += HelpKeyStyle.Render("[n]") + " No"

	return out
}


--------------------------------------------------
File End
--------------------------------------------------


internal/state/app.go
File type: .go
package state

import "adbt/internal/adb"

type AppState struct {
	SelectedDevice *adb.Device
	Devices        []adb.Device
	Width          int
	Height         int
}

func New() *AppState {
	return &AppState{
		Devices: []adb.Device{},
	}
}

func (s *AppState) SelectDevice(device *adb.Device) {
	s.SelectedDevice = device
}

func (s *AppState) HasDevice() bool {
	return s.SelectedDevice != nil
}

func (s *AppState) DeviceSerial() string {
	if s.SelectedDevice == nil {
		return ""
	}
	return s.SelectedDevice.Serial
}


--------------------------------------------------
File End
--------------------------------------------------


internal/adb/device_info.go
File type: .go
package adb

import (
	"os/exec"
)

func StartScrcpy(serial string) error {
	cmd := exec.Command("scrcpy", "-s", serial)
	return cmd.Start()
}

func Reboot(serial string) error {
	_, err := ExecuteCommand(serial, "reboot")
	return err
}

func RebootRecovery(serial string) error {
	_, err := ExecuteCommand(serial, "reboot", "recovery")
	return err
}

func RebootBootloader(serial string) error {
	_, err := ExecuteCommand(serial, "reboot", "bootloader")
	return err
}


--------------------------------------------------
File End
--------------------------------------------------


internal/adb/logcat.go
File type: .go
package adb

import (
	"bufio"
	"os/exec"

	tea "github.com/charmbracelet/bubbletea"
)

type LogcatSession struct {
	cmd     *exec.Cmd
	scanner *bufio.Scanner
}

type LogcatStartedMsg struct {
	Session *LogcatSession
}

type LogcatLineMsg struct {
	Line string
}

type LogcatErrorMsg struct {
	Error error
}

type LogcatStoppedMsg struct{}

func StartLogcatCmd(serial string) tea.Cmd {
	return func() tea.Msg {
		cmd := exec.Command("adb", "-s", serial, "logcat")

		stdout, err := cmd.StdoutPipe()
		if err != nil {
			return LogcatErrorMsg{Error: err}
		}

		if err := cmd.Start(); err != nil {
			return LogcatErrorMsg{Error: err}
		}

		scanner := bufio.NewScanner(stdout)

		return LogcatStartedMsg{
			Session: &LogcatSession{
				cmd:     cmd,
				scanner: scanner,
			},
		}
	}
}

func NextLogcatLineCmd(s *LogcatSession) tea.Cmd {
	return func() tea.Msg {
		if s.scanner.Scan() {
			return LogcatLineMsg{Line: s.scanner.Text()}
		}

		if err := s.scanner.Err(); err != nil {
			return LogcatErrorMsg{Error: err}
		}

		_ = s.cmd.Wait()
		return LogcatStoppedMsg{}
	}
}

func StopLogcat(s *LogcatSession) {
	if s != nil && s.cmd != nil && s.cmd.Process != nil {
		_ = s.cmd.Process.Kill()
	}
}


--------------------------------------------------
File End
--------------------------------------------------


internal/adb/client.go
File type: .go
package adb

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

func ExecuteCommand(serial string, args ...string) ([]byte, error) {
	var cmdArgs []string
	if serial != "" {
		cmdArgs = append(cmdArgs, "-s", serial)
	}
	cmdArgs = append(cmdArgs, args...)

	cmd := exec.Command("adb", cmdArgs...)
	out, err := cmd.CombinedOutput()

	if err != nil {
		return out, fmt.Errorf("%w: %s", err, bytes.TrimSpace(out))
	}
	return out, nil
}

func GetProperty(serial, prop string) (string, error) {
	out, err := ExecuteCommand(serial, "shell", "getprop", prop)
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

func ParseLines(data []byte) []string {
	lines := strings.Split(string(data), "\n")
	result := make([]string, 0, len(lines))

	for _, line := range lines {
		if trimmed := strings.TrimSpace(line); trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}


--------------------------------------------------
File End
--------------------------------------------------


internal/adb/devices.go
File type: .go
package adb

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
)

type Device struct {
	Serial  string
	Model   string
	State   string
	Android string
}

type DevicesLoadedMsg struct {
	Devices []Device
	Error   error
}

type DeviceSelectedMsg struct {
	Device *Device
}

func ListDevices() tea.Cmd {
	return func() tea.Msg {
		out, err := ExecuteCommand("", "devices")
		if err != nil {
			return DevicesLoadedMsg{Error: fmt.Errorf("failed to list devices: %w", err)}
		}

		lines := ParseLines(out)

		if len(lines) > 0 && strings.Contains(strings.ToLower(lines[0]), "list of devices") {
			lines = lines[1:]
		}

		devices := make([]Device, 0, len(lines))
		for _, line := range lines {
			parts := strings.Fields(line)
			if len(parts) < 2 {
				continue
			}

			device := Device{
				Serial: parts[0],
				State:  parts[1],
			}

			if device.State == "device" {
				device.Model, _ = GetProperty(device.Serial, "ro.product.model")
				device.Android, _ = GetProperty(device.Serial, "ro.build.version.release")
			}

			devices = append(devices, device)
		}

		return DevicesLoadedMsg{Devices: devices}
	}
}

func PairWireless(addr string, port string, pin string) error {
	out, err := ExecuteCommand("", "pair "+addr+":"+port+" "+pin)
	if err != nil {
		return fmt.Errorf("failed to pair with device %s: %w", addr, err)
	}

	if !strings.Contains(string(out), "Successfully paired to") {
		return fmt.Errorf("failed to pair with device %s: %s", addr, strings.TrimSpace(string(out)))
	}
	return nil
}

func (d *Device) DisplayName() string {
	if d.Model != "" {
		return fmt.Sprintf("%s (%s)", d.Model, d.Serial)
	}
	return d.Serial
}

func (d *Device) IsConnected() bool {
	return d.State == "device"
}


--------------------------------------------------
File End
--------------------------------------------------
